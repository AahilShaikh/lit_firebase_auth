// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'auth_config.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$AuthConfigTearOff {
  const _$AuthConfigTearOff();

  _AuthConfig call(
      {Widget title,
      ButtonConfig emailButton,
      ButtonConfig passwordButton,
      ButtonConfig anonymousButton,
      ButtonConfig googleButton,
      ButtonConfig appleButton,
      InputDecoration emailTextFormField,
      InputDecoration passwordTextFormField}) {
    return _AuthConfig(
      title: title,
      emailButton: emailButton,
      passwordButton: passwordButton,
      anonymousButton: anonymousButton,
      googleButton: googleButton,
      appleButton: appleButton,
      emailTextFormField: emailTextFormField,
      passwordTextFormField: passwordTextFormField,
    );
  }
}

// ignore: unused_element
const $AuthConfig = _$AuthConfigTearOff();

mixin _$AuthConfig {
  Widget get title;
  ButtonConfig get emailButton;
  ButtonConfig get passwordButton;
  ButtonConfig get anonymousButton;
  ButtonConfig get googleButton;
  ButtonConfig get appleButton;
  InputDecoration get emailTextFormField;
  InputDecoration get passwordTextFormField;

  $AuthConfigCopyWith<AuthConfig> get copyWith;
}

abstract class $AuthConfigCopyWith<$Res> {
  factory $AuthConfigCopyWith(
          AuthConfig value, $Res Function(AuthConfig) then) =
      _$AuthConfigCopyWithImpl<$Res>;
  $Res call(
      {Widget title,
      ButtonConfig emailButton,
      ButtonConfig passwordButton,
      ButtonConfig anonymousButton,
      ButtonConfig googleButton,
      ButtonConfig appleButton,
      InputDecoration emailTextFormField,
      InputDecoration passwordTextFormField});

  $ButtonConfigCopyWith<$Res> get emailButton;
  $ButtonConfigCopyWith<$Res> get passwordButton;
  $ButtonConfigCopyWith<$Res> get anonymousButton;
  $ButtonConfigCopyWith<$Res> get googleButton;
  $ButtonConfigCopyWith<$Res> get appleButton;
}

class _$AuthConfigCopyWithImpl<$Res> implements $AuthConfigCopyWith<$Res> {
  _$AuthConfigCopyWithImpl(this._value, this._then);

  final AuthConfig _value;
  // ignore: unused_field
  final $Res Function(AuthConfig) _then;

  @override
  $Res call({
    Object title = freezed,
    Object emailButton = freezed,
    Object passwordButton = freezed,
    Object anonymousButton = freezed,
    Object googleButton = freezed,
    Object appleButton = freezed,
    Object emailTextFormField = freezed,
    Object passwordTextFormField = freezed,
  }) {
    return _then(_value.copyWith(
      title: title == freezed ? _value.title : title as Widget,
      emailButton: emailButton == freezed
          ? _value.emailButton
          : emailButton as ButtonConfig,
      passwordButton: passwordButton == freezed
          ? _value.passwordButton
          : passwordButton as ButtonConfig,
      anonymousButton: anonymousButton == freezed
          ? _value.anonymousButton
          : anonymousButton as ButtonConfig,
      googleButton: googleButton == freezed
          ? _value.googleButton
          : googleButton as ButtonConfig,
      appleButton: appleButton == freezed
          ? _value.appleButton
          : appleButton as ButtonConfig,
      emailTextFormField: emailTextFormField == freezed
          ? _value.emailTextFormField
          : emailTextFormField as InputDecoration,
      passwordTextFormField: passwordTextFormField == freezed
          ? _value.passwordTextFormField
          : passwordTextFormField as InputDecoration,
    ));
  }

  @override
  $ButtonConfigCopyWith<$Res> get emailButton {
    if (_value.emailButton == null) {
      return null;
    }
    return $ButtonConfigCopyWith<$Res>(_value.emailButton, (value) {
      return _then(_value.copyWith(emailButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res> get passwordButton {
    if (_value.passwordButton == null) {
      return null;
    }
    return $ButtonConfigCopyWith<$Res>(_value.passwordButton, (value) {
      return _then(_value.copyWith(passwordButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res> get anonymousButton {
    if (_value.anonymousButton == null) {
      return null;
    }
    return $ButtonConfigCopyWith<$Res>(_value.anonymousButton, (value) {
      return _then(_value.copyWith(anonymousButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res> get googleButton {
    if (_value.googleButton == null) {
      return null;
    }
    return $ButtonConfigCopyWith<$Res>(_value.googleButton, (value) {
      return _then(_value.copyWith(googleButton: value));
    });
  }

  @override
  $ButtonConfigCopyWith<$Res> get appleButton {
    if (_value.appleButton == null) {
      return null;
    }
    return $ButtonConfigCopyWith<$Res>(_value.appleButton, (value) {
      return _then(_value.copyWith(appleButton: value));
    });
  }
}

abstract class _$AuthConfigCopyWith<$Res> implements $AuthConfigCopyWith<$Res> {
  factory _$AuthConfigCopyWith(
          _AuthConfig value, $Res Function(_AuthConfig) then) =
      __$AuthConfigCopyWithImpl<$Res>;
  @override
  $Res call(
      {Widget title,
      ButtonConfig emailButton,
      ButtonConfig passwordButton,
      ButtonConfig anonymousButton,
      ButtonConfig googleButton,
      ButtonConfig appleButton,
      InputDecoration emailTextFormField,
      InputDecoration passwordTextFormField});

  @override
  $ButtonConfigCopyWith<$Res> get emailButton;
  @override
  $ButtonConfigCopyWith<$Res> get passwordButton;
  @override
  $ButtonConfigCopyWith<$Res> get anonymousButton;
  @override
  $ButtonConfigCopyWith<$Res> get googleButton;
  @override
  $ButtonConfigCopyWith<$Res> get appleButton;
}

class __$AuthConfigCopyWithImpl<$Res> extends _$AuthConfigCopyWithImpl<$Res>
    implements _$AuthConfigCopyWith<$Res> {
  __$AuthConfigCopyWithImpl(
      _AuthConfig _value, $Res Function(_AuthConfig) _then)
      : super(_value, (v) => _then(v as _AuthConfig));

  @override
  _AuthConfig get _value => super._value as _AuthConfig;

  @override
  $Res call({
    Object title = freezed,
    Object emailButton = freezed,
    Object passwordButton = freezed,
    Object anonymousButton = freezed,
    Object googleButton = freezed,
    Object appleButton = freezed,
    Object emailTextFormField = freezed,
    Object passwordTextFormField = freezed,
  }) {
    return _then(_AuthConfig(
      title: title == freezed ? _value.title : title as Widget,
      emailButton: emailButton == freezed
          ? _value.emailButton
          : emailButton as ButtonConfig,
      passwordButton: passwordButton == freezed
          ? _value.passwordButton
          : passwordButton as ButtonConfig,
      anonymousButton: anonymousButton == freezed
          ? _value.anonymousButton
          : anonymousButton as ButtonConfig,
      googleButton: googleButton == freezed
          ? _value.googleButton
          : googleButton as ButtonConfig,
      appleButton: appleButton == freezed
          ? _value.appleButton
          : appleButton as ButtonConfig,
      emailTextFormField: emailTextFormField == freezed
          ? _value.emailTextFormField
          : emailTextFormField as InputDecoration,
      passwordTextFormField: passwordTextFormField == freezed
          ? _value.passwordTextFormField
          : passwordTextFormField as InputDecoration,
    ));
  }
}

class _$_AuthConfig with DiagnosticableTreeMixin implements _AuthConfig {
  const _$_AuthConfig(
      {this.title,
      this.emailButton,
      this.passwordButton,
      this.anonymousButton,
      this.googleButton,
      this.appleButton,
      this.emailTextFormField,
      this.passwordTextFormField});

  @override
  final Widget title;
  @override
  final ButtonConfig emailButton;
  @override
  final ButtonConfig passwordButton;
  @override
  final ButtonConfig anonymousButton;
  @override
  final ButtonConfig googleButton;
  @override
  final ButtonConfig appleButton;
  @override
  final InputDecoration emailTextFormField;
  @override
  final InputDecoration passwordTextFormField;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AuthConfig(title: $title, emailButton: $emailButton, passwordButton: $passwordButton, anonymousButton: $anonymousButton, googleButton: $googleButton, appleButton: $appleButton, emailTextFormField: $emailTextFormField, passwordTextFormField: $passwordTextFormField)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AuthConfig'))
      ..add(DiagnosticsProperty('title', title))
      ..add(DiagnosticsProperty('emailButton', emailButton))
      ..add(DiagnosticsProperty('passwordButton', passwordButton))
      ..add(DiagnosticsProperty('anonymousButton', anonymousButton))
      ..add(DiagnosticsProperty('googleButton', googleButton))
      ..add(DiagnosticsProperty('appleButton', appleButton))
      ..add(DiagnosticsProperty('emailTextFormField', emailTextFormField))
      ..add(
          DiagnosticsProperty('passwordTextFormField', passwordTextFormField));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AuthConfig &&
            (identical(other.title, title) ||
                const DeepCollectionEquality().equals(other.title, title)) &&
            (identical(other.emailButton, emailButton) ||
                const DeepCollectionEquality()
                    .equals(other.emailButton, emailButton)) &&
            (identical(other.passwordButton, passwordButton) ||
                const DeepCollectionEquality()
                    .equals(other.passwordButton, passwordButton)) &&
            (identical(other.anonymousButton, anonymousButton) ||
                const DeepCollectionEquality()
                    .equals(other.anonymousButton, anonymousButton)) &&
            (identical(other.googleButton, googleButton) ||
                const DeepCollectionEquality()
                    .equals(other.googleButton, googleButton)) &&
            (identical(other.appleButton, appleButton) ||
                const DeepCollectionEquality()
                    .equals(other.appleButton, appleButton)) &&
            (identical(other.emailTextFormField, emailTextFormField) ||
                const DeepCollectionEquality()
                    .equals(other.emailTextFormField, emailTextFormField)) &&
            (identical(other.passwordTextFormField, passwordTextFormField) ||
                const DeepCollectionEquality().equals(
                    other.passwordTextFormField, passwordTextFormField)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(title) ^
      const DeepCollectionEquality().hash(emailButton) ^
      const DeepCollectionEquality().hash(passwordButton) ^
      const DeepCollectionEquality().hash(anonymousButton) ^
      const DeepCollectionEquality().hash(googleButton) ^
      const DeepCollectionEquality().hash(appleButton) ^
      const DeepCollectionEquality().hash(emailTextFormField) ^
      const DeepCollectionEquality().hash(passwordTextFormField);

  @override
  _$AuthConfigCopyWith<_AuthConfig> get copyWith =>
      __$AuthConfigCopyWithImpl<_AuthConfig>(this, _$identity);
}

abstract class _AuthConfig implements AuthConfig {
  const factory _AuthConfig(
      {Widget title,
      ButtonConfig emailButton,
      ButtonConfig passwordButton,
      ButtonConfig anonymousButton,
      ButtonConfig googleButton,
      ButtonConfig appleButton,
      InputDecoration emailTextFormField,
      InputDecoration passwordTextFormField}) = _$_AuthConfig;

  @override
  Widget get title;
  @override
  ButtonConfig get emailButton;
  @override
  ButtonConfig get passwordButton;
  @override
  ButtonConfig get anonymousButton;
  @override
  ButtonConfig get googleButton;
  @override
  ButtonConfig get appleButton;
  @override
  InputDecoration get emailTextFormField;
  @override
  InputDecoration get passwordTextFormField;
  @override
  _$AuthConfigCopyWith<_AuthConfig> get copyWith;
}

class _$ButtonConfigTearOff {
  const _$ButtonConfigTearOff();

  _ButtonConfig call(
      {ButtonThemeData themeData, ButtonType type, Widget child}) {
    return _ButtonConfig(
      themeData: themeData,
      type: type,
      child: child,
    );
  }
}

// ignore: unused_element
const $ButtonConfig = _$ButtonConfigTearOff();

mixin _$ButtonConfig {
  ButtonThemeData get themeData;
  ButtonType get type;
  Widget get child;

  $ButtonConfigCopyWith<ButtonConfig> get copyWith;
}

abstract class $ButtonConfigCopyWith<$Res> {
  factory $ButtonConfigCopyWith(
          ButtonConfig value, $Res Function(ButtonConfig) then) =
      _$ButtonConfigCopyWithImpl<$Res>;
  $Res call({ButtonThemeData themeData, ButtonType type, Widget child});

  $ButtonTypeCopyWith<$Res> get type;
}

class _$ButtonConfigCopyWithImpl<$Res> implements $ButtonConfigCopyWith<$Res> {
  _$ButtonConfigCopyWithImpl(this._value, this._then);

  final ButtonConfig _value;
  // ignore: unused_field
  final $Res Function(ButtonConfig) _then;

  @override
  $Res call({
    Object themeData = freezed,
    Object type = freezed,
    Object child = freezed,
  }) {
    return _then(_value.copyWith(
      themeData: themeData == freezed
          ? _value.themeData
          : themeData as ButtonThemeData,
      type: type == freezed ? _value.type : type as ButtonType,
      child: child == freezed ? _value.child : child as Widget,
    ));
  }

  @override
  $ButtonTypeCopyWith<$Res> get type {
    if (_value.type == null) {
      return null;
    }
    return $ButtonTypeCopyWith<$Res>(_value.type, (value) {
      return _then(_value.copyWith(type: value));
    });
  }
}

abstract class _$ButtonConfigCopyWith<$Res>
    implements $ButtonConfigCopyWith<$Res> {
  factory _$ButtonConfigCopyWith(
          _ButtonConfig value, $Res Function(_ButtonConfig) then) =
      __$ButtonConfigCopyWithImpl<$Res>;
  @override
  $Res call({ButtonThemeData themeData, ButtonType type, Widget child});

  @override
  $ButtonTypeCopyWith<$Res> get type;
}

class __$ButtonConfigCopyWithImpl<$Res> extends _$ButtonConfigCopyWithImpl<$Res>
    implements _$ButtonConfigCopyWith<$Res> {
  __$ButtonConfigCopyWithImpl(
      _ButtonConfig _value, $Res Function(_ButtonConfig) _then)
      : super(_value, (v) => _then(v as _ButtonConfig));

  @override
  _ButtonConfig get _value => super._value as _ButtonConfig;

  @override
  $Res call({
    Object themeData = freezed,
    Object type = freezed,
    Object child = freezed,
  }) {
    return _then(_ButtonConfig(
      themeData: themeData == freezed
          ? _value.themeData
          : themeData as ButtonThemeData,
      type: type == freezed ? _value.type : type as ButtonType,
      child: child == freezed ? _value.child : child as Widget,
    ));
  }
}

class _$_ButtonConfig with DiagnosticableTreeMixin implements _ButtonConfig {
  const _$_ButtonConfig({this.themeData, this.type, this.child});

  @override
  final ButtonThemeData themeData;
  @override
  final ButtonType type;
  @override
  final Widget child;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ButtonConfig(themeData: $themeData, type: $type, child: $child)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ButtonConfig'))
      ..add(DiagnosticsProperty('themeData', themeData))
      ..add(DiagnosticsProperty('type', type))
      ..add(DiagnosticsProperty('child', child));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _ButtonConfig &&
            (identical(other.themeData, themeData) ||
                const DeepCollectionEquality()
                    .equals(other.themeData, themeData)) &&
            (identical(other.type, type) ||
                const DeepCollectionEquality().equals(other.type, type)) &&
            (identical(other.child, child) ||
                const DeepCollectionEquality().equals(other.child, child)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(themeData) ^
      const DeepCollectionEquality().hash(type) ^
      const DeepCollectionEquality().hash(child);

  @override
  _$ButtonConfigCopyWith<_ButtonConfig> get copyWith =>
      __$ButtonConfigCopyWithImpl<_ButtonConfig>(this, _$identity);
}

abstract class _ButtonConfig implements ButtonConfig {
  const factory _ButtonConfig(
      {ButtonThemeData themeData,
      ButtonType type,
      Widget child}) = _$_ButtonConfig;

  @override
  ButtonThemeData get themeData;
  @override
  ButtonType get type;
  @override
  Widget get child;
  @override
  _$ButtonConfigCopyWith<_ButtonConfig> get copyWith;
}

class _$ButtonTypeTearOff {
  const _$ButtonTypeTearOff();

  _ButtonTypeRaised raised() {
    return const _ButtonTypeRaised();
  }

  _ButtonTypeFlat flat() {
    return const _ButtonTypeFlat();
  }
}

// ignore: unused_element
const $ButtonType = _$ButtonTypeTearOff();

mixin _$ButtonType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result raised(),
    @required Result flat(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result raised(),
    Result flat(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result raised(_ButtonTypeRaised value),
    @required Result flat(_ButtonTypeFlat value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result raised(_ButtonTypeRaised value),
    Result flat(_ButtonTypeFlat value),
    @required Result orElse(),
  });
}

abstract class $ButtonTypeCopyWith<$Res> {
  factory $ButtonTypeCopyWith(
          ButtonType value, $Res Function(ButtonType) then) =
      _$ButtonTypeCopyWithImpl<$Res>;
}

class _$ButtonTypeCopyWithImpl<$Res> implements $ButtonTypeCopyWith<$Res> {
  _$ButtonTypeCopyWithImpl(this._value, this._then);

  final ButtonType _value;
  // ignore: unused_field
  final $Res Function(ButtonType) _then;
}

abstract class _$ButtonTypeRaisedCopyWith<$Res> {
  factory _$ButtonTypeRaisedCopyWith(
          _ButtonTypeRaised value, $Res Function(_ButtonTypeRaised) then) =
      __$ButtonTypeRaisedCopyWithImpl<$Res>;
}

class __$ButtonTypeRaisedCopyWithImpl<$Res>
    extends _$ButtonTypeCopyWithImpl<$Res>
    implements _$ButtonTypeRaisedCopyWith<$Res> {
  __$ButtonTypeRaisedCopyWithImpl(
      _ButtonTypeRaised _value, $Res Function(_ButtonTypeRaised) _then)
      : super(_value, (v) => _then(v as _ButtonTypeRaised));

  @override
  _ButtonTypeRaised get _value => super._value as _ButtonTypeRaised;
}

class _$_ButtonTypeRaised
    with DiagnosticableTreeMixin
    implements _ButtonTypeRaised {
  const _$_ButtonTypeRaised();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ButtonType.raised()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ButtonType.raised'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ButtonTypeRaised);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result raised(),
    @required Result flat(),
  }) {
    assert(raised != null);
    assert(flat != null);
    return raised();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result raised(),
    Result flat(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (raised != null) {
      return raised();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result raised(_ButtonTypeRaised value),
    @required Result flat(_ButtonTypeFlat value),
  }) {
    assert(raised != null);
    assert(flat != null);
    return raised(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result raised(_ButtonTypeRaised value),
    Result flat(_ButtonTypeFlat value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (raised != null) {
      return raised(this);
    }
    return orElse();
  }
}

abstract class _ButtonTypeRaised implements ButtonType {
  const factory _ButtonTypeRaised() = _$_ButtonTypeRaised;
}

abstract class _$ButtonTypeFlatCopyWith<$Res> {
  factory _$ButtonTypeFlatCopyWith(
          _ButtonTypeFlat value, $Res Function(_ButtonTypeFlat) then) =
      __$ButtonTypeFlatCopyWithImpl<$Res>;
}

class __$ButtonTypeFlatCopyWithImpl<$Res> extends _$ButtonTypeCopyWithImpl<$Res>
    implements _$ButtonTypeFlatCopyWith<$Res> {
  __$ButtonTypeFlatCopyWithImpl(
      _ButtonTypeFlat _value, $Res Function(_ButtonTypeFlat) _then)
      : super(_value, (v) => _then(v as _ButtonTypeFlat));

  @override
  _ButtonTypeFlat get _value => super._value as _ButtonTypeFlat;
}

class _$_ButtonTypeFlat
    with DiagnosticableTreeMixin
    implements _ButtonTypeFlat {
  const _$_ButtonTypeFlat();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ButtonType.flat()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'ButtonType.flat'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ButtonTypeFlat);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result raised(),
    @required Result flat(),
  }) {
    assert(raised != null);
    assert(flat != null);
    return flat();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result raised(),
    Result flat(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (flat != null) {
      return flat();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result raised(_ButtonTypeRaised value),
    @required Result flat(_ButtonTypeFlat value),
  }) {
    assert(raised != null);
    assert(flat != null);
    return flat(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result raised(_ButtonTypeRaised value),
    Result flat(_ButtonTypeFlat value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (flat != null) {
      return flat(this);
    }
    return orElse();
  }
}

abstract class _ButtonTypeFlat implements ButtonType {
  const factory _ButtonTypeFlat() = _$_ButtonTypeFlat;
}
